
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Crypto Live Dashboard + Portfolio Scenarios</title>
  <style>
    :root{
      --bg:#0b0f14;--panel:#121821;--muted:#9fb0c3;--text:#e5eef7;--accent:#6ee7ff;
      --up:#2ecc71;--down:#e74c3c;--warn:#f1c40f;
    }
    *{box-sizing:border-box;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Helvetica,Arial,sans-serif}
    html,body{background:var(--bg);color:var(--text);margin:0}
    header{position:sticky;top:0;z-index:5;background:linear-gradient(180deg,var(--bg),rgba(11,15,20,.6));
      backdrop-filter:saturate(1.2) blur(6px);border-bottom:1px solid rgba(255,255,255,.06)}
    .wrap{max-width:1260px;margin:0 auto;padding:16px}
    h1{font-size:20px;margin:0 0 6px 0}
    .sub{font-size:12px;color:var(--muted)}
    .grid{display:grid;gap:12px;margin-top:12px}
    @media(min-width:1000px){.grid{grid-template-columns: 1.1fr 0.9fr}}
    .panel{background:var(--panel);border:1px solid rgba(255,255,255,.08);border-radius:12px;padding:12px}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .btn{cursor:pointer;padding:8px 10px;border-radius:8px;border:1px solid rgba(255,255,255,.12);background:#10161f;color:var(--text);font-size:14px}
    .btn:active{transform:translateY(1px)}
    .pill{padding:4px 8px;border-radius:999px;font-size:12px;border:1px solid rgba(255,255,255,.12);color:var(--muted)}
    input,select{background:#0f141c;border:1px solid rgba(255,255,255,.12);color:var(--text);border-radius:8px;padding:8px;font-size:14px}
    table{width:100%;border-collapse:collapse;font-size:13px}
    th,td{padding:8px;border-bottom:1px solid rgba(255,255,255,.08);text-align:right}
    th:first-child,td:first-child{text-align:left}
    .chgUp{color:var(--up)} .chgDown{color:var(--down)}
    .signal{font-weight:600;padding:4px 8px;border-radius:8px;display:inline-block}
    .buy{background:rgba(46,204,113,.12);border:1px solid rgba(46,204,113,.35);color:var(--up)}
    .watch{background:rgba(241,196,15,.12);border:1px solid rgba(241,196,15,.35);color:var(--warn)}
    .hold{background:rgba(231,76,60,.12);border:1px solid rgba(231,76,60,.35);color:var(--down)}
    canvas{width:100%;height:260px}
    .small{font-size:12px;color:var(--muted)}
    .news-list{list-style:none;margin:0;padding:0;max-height:360px;overflow:auto}
    .news-list li{padding:8px;border-bottom:1px solid rgba(255,255,255,.06)}
    .scoreBox{display:flex;align-items:center;gap:8px;margin:6px 0 10px}
    .scoreBar{flex:1;height:8px;background:#0f141c;border-radius:8px;position:relative;border:1px solid rgba(255,255,255,.08)}
    .scoreFill{position:absolute;left:0;top:0;bottom:0;border-radius:8px;background:linear-gradient(90deg, var(--down), var(--warn), var(--up))}
    .cards{display:grid;gap:12px}
    @media(min-width:1000px){.cards{grid-template-columns: repeat(2,1fr)}}
    footer{color:var(--muted);font-size:12px;padding:16px}
    a{color:var(--accent);text-decoration:none}
    .hint{color:var(--muted);font-size:11px}
    .num{width:110px}
    .sym{min-width:110px}
    .del{cursor:pointer}
  </style>
</head>
<body>
<header>
  <div class="wrap">
    <h1>Crypto Dashboard + Portfolio Scenarios</h1>
    <div class="sub">Top 5 by market cap • Technicals • News sentiment • Portfolio signals & buy suggestions • Scenario testing • Local save</div>
  </div>
</header>

<main class="wrap">
  <div class="grid">
    <section class="panel">
      <div class="row" style="justify-content:space-between">
        <div class="row">
          <select id="vsCurrency">
            <option value="usd">USD</option>
            <option value="eur">EUR</option>
            <option value="gbp">GBP</option>
          </select>
          <select id="risk">
            <option value="balanced">Risk: Balanced</option>
            <option value="conservative">Risk: Conservative</option>
            <option value="aggressive">Risk: Aggressive</option>
          </select>
          <button class="btn" id="refresh">Refresh</button>
        </div>
        <div class="small" id="asof"></div>
      </div>
      <div style="overflow:auto">
        <table id="topTable">
          <thead><tr>
            <th>Asset</th><th>Price</th><th>1h</th><th>24h</th><th>7d</th><th>Market Cap</th><th>Volume</th><th>Signal</th>
          </tr></thead>
          <tbody></tbody>
        </table>
      </div>
      <div class="hint">Signals combine RSI/MACD/SMA/Bollinger + news score, weighted by risk profile.</div>
    </section>

    <section class="panel">
      <div class="row" style="justify-content:space-between">
        <strong>Headlines / Macro Pulse</strong>
        <div class="row">
          <select id="newsSource">
            <option value="mixed">Mixed (Reuters + CoinDesk)</option>
            <option value="crypto">Crypto only</option>
            <option value="reuters">Macro only</option>
          </select>
          <button class="btn" id="loadNews">Load</button>
        </div>
      </div>
      <div class="scoreBox">
        <div class="pill">News score</div>
        <div class="scoreBar"><div id="newsFill" class="scoreFill" style="width:50%"></div></div>
        <div id="newsScore">0</div>
        <div class="row"><span class="pill">Override</span><input id="newsOverride" type="range" min="-5" max="5" step="0.5" value="0"><span id="newsOverrideVal" class="pill">0.0</span></div>
      </div>
      <ul id="newsList" class="news-list"></ul>
      <div class="hint">Override lets you nudge sentiment based on your own read of events (e.g., policy changes, ETF flows, CPI).</div>
    </section>
  </div>

  <section class="panel">
    <div class="row" style="justify-content:space-between">
      <strong>Charts & Indicators</strong>
      <div class="row">
        <select id="assetSelect"></select>
        <select id="rangeSelect">
          <option value="1">24H</option>
          <option value="7">7D</option>
          <option value="30" selected>30D</option>
          <option value="90">90D</option>
          <option value="365">1Y</option>
          <option value="max">MAX</option>
        </select>
        <button class="btn" id="loadChart">Update</button>
      </div>
    </div>
    <div class="cards">
      <div class="panel"><canvas id="priceChart"></canvas><div id="techSummary" class="small"></div></div>
      <div class="panel"><canvas id="macdChart"></canvas></div>
    </div>
  </section>

  <section class="panel">
    <div class="row" style="justify-content:space-between">
      <strong>Your Portfolio & Scenarios</strong>
      <div class="row">
        <button class="btn" id="save">Save</button>
        <button class="btn" id="load">Load</button>
        <button class="btn" id="reset">Reset</button>
      </div>
    </div>

    <div class="row" style="margin:6px 0">
      <div class="pill">Cash on hand</div><input class="num" id="cash" type="number" step="0.01" value="1000">
      <div class="pill">Tx fee %</div><input class="num" id="fee" type="number" step="0.01" value="0.10">
      <div class="pill">Max pos %</div><input class="num" id="maxPos" type="number" step="0.5" value="40">
      <div class="pill">Min order $</div><input class="num" id="minOrder" type="number" step="1" value="50">
      <div class="pill">Scenario: market %</div><input class="num" id="scenarioAll" type="number" step="0.5" value="0">
      <button class="btn" id="applyScenario">Apply</button>
    </div>

    <div class="row" style="margin:6px 0">
      <input id="search" class="sym" placeholder="Search coin (e.g., bitcoin, eth)">
      <button class="btn" id="addRow">Add</button>
      <div class="hint">Search pulls CoinGecko list; then adjust amounts, cost basis, and target % below.</div>
    </div>

    <div style="overflow:auto">
      <table id="holdings">
        <thead><tr>
          <th>Symbol</th><th>Name</th><th>Amount</th><th>Cost Basis (per)</th><th>Target %</th><th>Scenario %</th><th>Price</th><th>Value</th><th>P/L $</th><th>P/L %</th><th>Signal</th><th></th>
        </tr></thead>
        <tbody></tbody>
        <tfoot>
          <tr>
            <th colspan="6" style="text-align:right">Totals</th>
            <th id="totalsPrice"></th>
            <th id="totalsValue"></th>
            <th id="totalsPL"></th>
            <th id="totalsPLpct"></th>
            <th></th><th></th>
          </tr>
        </tfoot>
      </table>
    </div>

    <div class="panel" style="margin-top:12px">
      <div class="row" style="justify-content:space-between">
        <strong>Buy Suggestions</strong>
        <div class="hint">Based on gaps to target allocation under scenario, limited by max position %, min order, fees, and current signals/news.</div>
      </div>
      <div style="overflow:auto">
        <table id="suggestions">
          <thead><tr>
            <th>Asset</th><th>Current %</th><th>Target %</th><th>Gap %</th><th>Signal</th><th>Recommended Buy ($)</th><th>Est. Units</th><th>Note</th>
          </tr></thead>
          <tbody></tbody>
        </table>
      </div>
    </div>
  </section>
</main>

<footer class="wrap">
  Educational tool — not financial advice. Data: CoinGecko, Reuters/CoinDesk RSS. Built for Caleb.
</footer>

<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
<script>
const API = "https://api.coingecko.com/api/v3";
const $ = (id)=>document.getElementById(id);
const moneyFmt = (cur)=> new Intl.NumberFormat(undefined,{style:'currency',currency:cur.toUpperCase(),maximumFractionDigits:2});
const numFmt = new Intl.NumberFormat(undefined,{maximumFractionDigits:6});
const pctFmt = (v)=> (v>0?'+':'')+v.toFixed(2)+'%';
let CUR='usd', RISK='balanced', TOP=[], HIST={}, NEWS_SCORE=0, NEWS_OVERRIDE=0;
let COIN_INDEX=[]; // from /coins/list for search
let HOLD=[]; // {id,symbol,name,amount,cost, target, scenPct, price, signalScore}

function SMA(values, period){const out=[];let s=0;for(let i=0;i<values.length;i++){s+=values[i];if(i>=period)s-=values[i-period];out.push(i>=period-1?s/period:null);}return out;}
function EMA(values, period){const out=[];const k=2/(period+1);let ema=null;for(let i=0;i<values.length;i++){const v=values[i];if(ema===null){ema=v;}else{ema=v*k+ema*(1-k);}out.push(i<period-1?null:ema);}return out;}
function MACD(values, fast=12, slow=26, signal=9){const f=EMA(values,fast), s=EMA(values,slow);const macd=values.map((_,i)=> (f[i]!==null&&s[i]!==null)?(f[i]-s[i]):null);const sig=EMA(macd.map(v=>v??0),signal).map((v,i)=> macd[i]===null?null:v);const hist=macd.map((v,i)=> (v===null||sig[i]===null)?null:v-sig[i]);return {macd,signal:sig,hist};}
function RSI(values, period=14){let avgGain=0,avgLoss=0;const out=[null];for(let i=1;i<values.length;i++){const ch=values[i]-values[i-1];const g=Math.max(ch,0), l=Math.max(-ch,0);if(i<=period){avgGain+=g;avgLoss+=l;out.push(null);if(i===period){avgGain/=period;avgLoss/=period;const rs=avgLoss===0?100:avgGain/avgLoss;out[i]=100-(100/(1+rs));}}else{avgGain=(avgGain*(period-1)+g)/period;avgLoss=(avgLoss*(period-1)+l)/period;const rs=avgLoss===0?100:avgGain/avgLoss;out.push(100-(100/(1+rs)));}}return out;}
function Bollinger(values, period=20, mult=2){const sma=SMA(values,period);return values.map((v,i)=>{if(i<period-1)return{mid:null,upper:null,lower:null};const mean=sma[i];let variance=0;for(let j=i-period+1;j<=i;j++){const d=values[j]-mean;variance+=d*d;}const std=Math.sqrt(variance/period);return{mid:mean,upper:mean+mult*std,lower:mean-mult*std};});}
function signalFromTechnicals(values, risk="balanced"){
  const rsi=RSI(values,14), bb=Bollinger(values,20,2), macd=MACD(values,12,26,9), sma50=SMA(values,50), sma200=SMA(values,200);
  const i=values.length-1; const latest={price:values[i], rsi:rsi[i], bb:bb[i], macd:{line:macd.macd[i],signal:macd.signal[i],hist:macd.hist[i]}, sma50:sma50[i], sma200:sma200[i]};
  let score=0;
  if(latest.rsi!==null){if(latest.rsi<30)score+=3; else if(latest.rsi>70)score-=3;}
  if(latest.bb.lower && latest.price<=latest.bb.lower)score+=2;
  if(latest.bb.upper && latest.price>=latest.bb.upper)score-=2;
  if(latest.macd.line!==null && latest.macd.signal!==null){if(latest.macd.line>latest.macd.signal)score+=2; else score-=1;}
  if(latest.sma50 && latest.sma200){if(latest.price>latest.sma50)score+=1; else score-=1; if(latest.sma50>latest.sma200)score+=2; else score-=2;}
  const mult = risk==="aggressive"?1.3: risk==="conservative"?0.8:1.0;
  score = Math.max(-10, Math.min(10, score*mult));
  return {score, latest, rsi, bb, macd, sma50, sma200};
}
function labelForScore(score){ if(score>=3) return {label:"BUY ZONE", cls:"buy"}; if(score>=0.5) return {label:"WATCH", cls:"watch"}; return {label:"HOLD", cls:"hold"}; }

async function loadTop(){
  const res = await fetch(`${API}/coins/markets?vs_currency=${CUR}&order=market_cap_desc&per_page=5&page=1&sparkline=true&price_change_percentage=1h,24h,7d`);
  TOP = await res.json();
  const tb = $("topTable").querySelector("tbody"); tb.innerHTML="";
  TOP.forEach(c=>{
    const tr=document.createElement("tr");
    tr.innerHTML=`
      <td><span class="pill">${c.symbol.toUpperCase()}</span> ${c.name}</td>
      <td>${moneyFmt(CUR).format(c.current_price)}</td>
      <td class="${c.price_change_percentage_1h_in_currency>=0?'chgUp':'chgDown'}">${pctFmt(c.price_change_percentage_1h_in_currency)}</td>
      <td class="${c.price_change_percentage_24h_in_currency>=0?'chgUp':'chgDown'}">${pctFmt(c.price_change_percentage_24h_in_currency)}</td>
      <td class="${c.price_change_percentage_7d_in_currency>=0?'chgUp':'chgDown'}">${pctFmt(c.price_change_percentage_7d_in_currency)}</td>
      <td>${moneyFmt(CUR).format(c.market_cap)}</td>
      <td>${moneyFmt(CUR).format(c.total_volume)}</td>
      <td class="sigCell"><span class="signal watch">…</span></td>`;
    tb.appendChild(tr);
  });
  $("asof").textContent = "As of " + new Date().toLocaleString();
  // fill selectors
  const sel=$("assetSelect"); sel.innerHTML="";
  TOP.forEach(c=>{ const o=document.createElement("option"); o.value=c.id; o.textContent=`${c.name} (${c.symbol.toUpperCase()})`; sel.appendChild(o);});
  // compute quick signals
  TOP.forEach((c,idx)=>{
    const prices = (c.sparkline_in_7d?.price || []).slice(-300);
    if(prices.length>30){
      const tech=signalFromTechnicals(prices,RISK);
      const totalScore = Math.max(-10, Math.min(10, tech.score + (NEWS_SCORE+NEWS_OVERRIDE)*0.5));
      const {label, cls}=labelForScore(totalScore);
      const cell = tb.rows[idx].querySelector(".sigCell");
      const div = cell.querySelector(".signal"); div.textContent = `${label} (${totalScore.toFixed(1)})`; div.className="signal "+cls;
    }
  });
}

let priceChart, macdChart;
async function loadHistory(id, days){
  const url = `${API}/coins/${id}/market_chart?vs_currency=${CUR}&days=${days}`;
  const res = await fetch(url); const data = await res.json();
  HIST[id]={t:data.prices.map(p=>p[0]), p:data.prices.map(p=>p[1])};
  drawCharts(id);
}
function drawCharts(id){
  const {t,p} = HIST[id]; const ctx1=$("priceChart").getContext("2d"); const ctx2=$("macdChart").getContext("2d");
  const tech = signalFromTechnicals(p,RISK), bb=tech.bb;
  const sma20=SMA(p,20), sma50=tech.sma50, sma200=tech.sma200, upper=bb.map(b=>b.upper), lower=bb.map(b=>b.lower);
  if(priceChart) priceChart.destroy();
  priceChart = new Chart(ctx1,{type:'line',data:{labels:t.map(ts=>new Date(ts)),datasets:[
    {label:'Price',data:p,pointRadius:0,borderWidth:1.5},
    {label:'SMA20',data:sma20,pointRadius:0,borderWidth:1},
    {label:'SMA50',data:sma50,pointRadius:0,borderWidth:1},
    {label:'SMA200',data:sma200,pointRadius:0,borderWidth:1},
    {label:'BB Upper',data:upper,pointRadius:0,borderWidth:1},
    {label:'BB Lower',data:lower,pointRadius:0,borderWidth:1},
  ]},options:{responsive:true,maintainAspectRatio:false,scales:{x:{type:'time', time:{unit:'day'}}, y:{ticks:{callback:(v)=>moneyFmt(CUR).format(v)}}},plugins:{legend:{position:'bottom'}}});
  if(macdChart) macdChart.destroy();
  macdChart = new Chart(ctx2,{type:'bar',data:{labels:t.map(ts=>new Date(ts)),datasets:[
    {type:'line',label:'MACD',data:tech.macd.macd,pointRadius:0,borderWidth:1.2},
    {type:'line',label:'Signal',data:tech.macd.signal,pointRadius:0,borderWidth:1},
    {label:'Histogram',data:tech.macd.hist}
  ]},options:{responsive:true,maintainAspectRatio:false,scales:{x:{type:'time',time:{unit:'day'}},y:{}},plugins:{legend:{position:'bottom'}}});
  const totalScore = Math.max(-10, Math.min(10, tech.score + (NEWS_SCORE+NEWS_OVERRIDE)*0.5));
  const {label, cls} = labelForScore(totalScore);
  $("techSummary").innerHTML = `<span class="signal ${cls}">${label} (${totalScore.toFixed(1)})</span>
    <span class="pill">RSI: ${tech.latest.rsi?tech.latest.rsi.toFixed(1):'–'}</span>
    <span class="pill">MACD hist: ${tech.latest.macd.hist?tech.latest.macd.hist.toFixed(4):'–'}</span>
    <span class="pill">SMA50: ${tech.latest.sma50?moneyFmt(CUR).format(tech.latest.sma50):'–'}</span>
    <span class="pill">SMA200: ${tech.latest.sma200?moneyFmt(CUR).format(tech.latest.sma200):'–'}</span>`;
}

async function ensureCoinIndex(){
  if(COIN_INDEX.length) return COIN_INDEX;
  const res = await fetch(`${API}/coins/list?include_platform=false`);
  COIN_INDEX = await res.json();
  return COIN_INDEX;
}
function findCoin(q){
  q = q.trim().toLowerCase();
  const exact = COIN_INDEX.find(c=>c.id===q || c.symbol===q || c.name.toLowerCase()===q);
  if(exact) return exact;
  return COIN_INDEX.find(c=> c.symbol===q) || COIN_INDEX.find(c=> c.name.toLowerCase().includes(q)) || COIN_INDEX.find(c=> c.id.includes(q));
}

function renderHoldings(){
  const tb = $("holdings").querySelector("tbody"); tb.innerHTML="";
  let totalValue=Number($("cash").value||0); let totalCost=0;
  HOLD.forEach((h,idx)=>{
    const curVal = (h.price||0) * (h.amount||0);
    const cost = (h.amount||0) * (h.cost||0);
    const pl = curVal - cost;
    const plpct = cost>0 ? (pl/cost*100) : 0;
    totalValue += curVal; totalCost += cost;
    const {label, cls} = labelForScore(h.signalScore ?? 0);
    const tr = document.createElement("tr");
    tr.innerHTML=`
      <td>${h.symbol?.toUpperCase()||''}</td>
      <td>${h.name||''}</td>
      <td><input class="num" type="number" step="0.00000001" value="${h.amount||0}" data-i="${idx}" data-k="amount"></td>
      <td><input class="num" type="number" step="0.01" value="${h.cost||0}" data-i="${idx}" data-k="cost"></td>
      <td><input class="num" type="number" step="0.5" value="${h.target||0}" data-i="${idx}" data-k="target"></td>
      <td><input class="num" type="number" step="0.5" value="${h.scenPct||0}" data-i="${idx}" data-k="scenPct"></td>
      <td>${h.price? moneyFmt(CUR).format(h.price):'–'}</td>
      <td>${moneyFmt(CUR).format(curVal)}</td>
      <td class="${pl>=0?'chgUp':'chgDown'}">${moneyFmt(CUR).format(pl)}</td>
      <td class="${pl>=0?'chgUp':'chgDown'}">${plpct?plpct.toFixed(2)+'%':'–'}</td>
      <td><span class="signal ${cls}">${label} ${(h.signalScore??0).toFixed(1)}</span></td>
      <td class="del" data-del="${idx}">✕</td>`;
    tb.appendChild(tr);
  });
  // totals
  const portfolioWithoutCash = totalValue - Number($("cash").value||0);
  $("totalsPrice").textContent = '—';
  $("totalsValue").textContent = moneyFmt(CUR).format(totalValue);
  const totPL = totalValue - (totalCost + Number($("cash").value||0));
  $("totalsPL").textContent = moneyFmt(CUR).format(totPL);
  $("totalsPL").className = totPL>=0?'chgUp':'chgDown';
  $("totalsPLpct").textContent = totalCost>0 ? (totPL/totalCost*100).toFixed(2)+'%' : '–';
  // bind inputs
  tb.querySelectorAll("input").forEach(el=>{
    el.onchange = (e)=>{
      const i=+e.target.dataset.i, k=e.target.dataset.k, v=parseFloat(e.target.value)||0;
      HOLD[i][k]=v; persistTemp(); computeSuggestions();
    };
  });
  tb.querySelectorAll('.del').forEach(el=>{
    el.onclick = (e)=>{ const i=+e.target.dataset.del; HOLD.splice(i,1); persistTemp(); computeSuggestions(); renderHoldings(); };
  });
}

async function updateHoldingsPricesAndSignals(){
  if(!HOLD.length) return;
  const ids = HOLD.map(h=>h.id).join(',');
  const res = await fetch(`${API}/simple/price?ids=${ids}&vs_currencies=${CUR}&include_last_updated_at=true`);
  const prices = await res.json();
  // get 30D history for signals
  for(const h of HOLD){
    h.price = prices[h.id]?.[CUR] || null;
    try{
      const hist = await (await fetch(`${API}/coins/${h.id}/market_chart?vs_currency=${CUR}&days=30`)).json();
      const p = hist.prices.map(a=>a[1]);
      const tScore = signalFromTechnicals(p,RISK).score;
      h.signalScore = Math.max(-10, Math.min(10, tScore + (NEWS_SCORE+NEWS_OVERRIDE)*0.5));
    }catch(e){ h.signalScore = 0; }
  }
  renderHoldings(); computeSuggestions();
}

function blendedSignalText(score){ const {label} = labelForScore(score); return `${label} (${score.toFixed(1)})`; }

function computeSuggestions(){
  // Portfolio math under scenario
  const fee = (parseFloat($("fee").value)||0)/100;
  const maxPos = (parseFloat($("maxPos").value)||0)/100;
  const minOrder = parseFloat($("minOrder").value)||0;
  const cash = parseFloat($("cash").value)||0;
  const scenAll = parseFloat($("scenarioAll").value)||0;
  let total = cash;
  const rows = HOLD.map(h=>{
    const scen = (h.scenPct||0) + scenAll;
    const scenPrice = h.price ? h.price * (1 + scen/100) : 0;
    const value = (h.amount||0) * scenPrice;
    return {...h, scenPrice, value};
  });
  total += rows.reduce((a,b)=>a+b.value,0);

  const currentPerc = rows.map(r=> ({...r, perc: total>0 ? r.value/total : 0}));
  const tb = $("suggestions").querySelector("tbody"); tb.innerHTML="";
  // Suggested buys: allocate cash to close gap where (target% - current%)>0 and signal >= watch (>=0.5)
  const candidates = currentPerc
    .map(r=>{
      const gap = Math.max(0, (r.target||0)/100 - r.perc);
      const allowed = Math.max(0, maxPos - r.perc); // max position cap
      const effGap = Math.min(gap, allowed);
      return {...r, gap, effGap};
    })
    .filter(r=> r.scenPrice>0 && r.effGap>0 && (r.signalScore??0) >= 0.5)
    .sort((a,b)=> (b.signalScore??0) - (a.signalScore??0) || b.effGap - a.effGap);

  let cashLeft = cash;
  for(const r of candidates){
    const targetDollar = total * r.effGap;
    let buyDollar = Math.min(cashLeft, targetDollar);
    if(buyDollar < minOrder) continue;
    // include fees
    const buyDollarWithFee = buyDollar * (1 - fee);
    const units = buyDollarWithFee / r.scenPrice;
    cashLeft -= buyDollar;
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${r.name} (${r.symbol.toUpperCase()})</td>
      <td>${(r.perc*100).toFixed(2)}%</td>
      <td>${(r.target||0).toFixed(1)}%</td>
      <td>${(r.gap*100).toFixed(2)}%</td>
      <td>${blendedSignalText(r.signalScore??0)}</td>
      <td>${moneyFmt(CUR).format(buyDollar)}</td>
      <td>${numFmt.format(units)}</td>
      <td>${cashLeft>0?'':'(cash exhausted)'}${r.signalScore>=3?' — strong techs':' — moderate'}</td>`;
    tb.appendChild(tr);
  }
  if(!tb.children.length){
    const tr=document.createElement("tr");
    tr.innerHTML=`<td colspan="8" class="small">No suggested buys under current settings (either no gaps, insufficient cash, or signals below WATCH).</td>`;
    tb.appendChild(tr);
  }
}

async function loadRSS(kind){
  const feeds = {
    mixed: [
      "https://www.reuters.com/finance/markets/rss",
      "https://www.coindesk.com/arc/outboundfeeds/rss/",
    ],
    crypto: ["https://www.coindesk.com/arc/outboundfeeds/rss/"],
    reuters: ["https://www.reuters.com/finance/markets/rss"]
  }[kind||'mixed'];
  const relay="https://api.allorigins.win/get?url=";
  const items=[];
  for(const u of feeds){
    try{
      const res=await fetch(relay+encodeURIComponent(u)); if(!res.ok) continue;
      const data=await res.json();
      const xml=new DOMParser().parseFromString(data.contents,"text/xml");
      Array.from(xml.querySelectorAll("item")).slice(0,20).forEach(n=>{
        items.push({title:n.querySelector("title")?.textContent.trim()||"", link:n.querySelector("link")?.textContent.trim()||"", pubDate:n.querySelector("pubDate")?.textContent.trim()||""});
      });
    }catch(e){}
  }
  return items;
}
function scoreNews(items){
  const bull=[/etf (approved|flows|inflows)/i, /(rate|rates) (cut|pause|hold)/i, /dovish/i, /cpi (falls|cool|below)/i, /(spot|bitcoin|ethereum) etf inflow/i, /upgrade|partnership|adoption/i];
  const bear=[/hack|exploit|bridge attack|rug pull/i, /ban|restrict|prohibit/i, /sec (sues|charges|complaint)/i, /(rate|rates) (hike|raises)/i, /hawkish/i, /cpi (rises|above|hot)/i, /downgrade|liquidation/i];
  let score=0,total=0;
  const scored = items.map(it=>{let s=0; bull.forEach(r=>{if(r.test(it.title))s+=2}); bear.forEach(r=>{if(r.test(it.title))s-=2}); total++; score+=s; return {...it,s};});
  const norm = total? Math.max(-10,Math.min(10,score)) : 0;
  return {score:norm, items:scored};
}

function persistTemp(){
  const state = {CUR,RISK,HOLD, cash:$("cash").value, fee:$("fee").value, maxPos:$("maxPos").value, minOrder:$("minOrder").value};
  localStorage.setItem("caleb_crypto_state", JSON.stringify(state));
}
function loadTemp(){
  const raw = localStorage.getItem("caleb_crypto_state");
  if(!raw) return;
  try{ const s = JSON.parse(raw);
    CUR=s.CUR||'usd'; $("vsCurrency").value=CUR;
    RISK=s.RISK||'balanced'; $("risk").value=RISK;
    HOLD=s.HOLD||[];
    $("cash").value=s.cash||1000; $("fee").value=s.fee||0.1; $("maxPos").value=s.maxPos||40; $("minOrder").value=s.minOrder||50;
  }catch(e){}
}

$("save").onclick = ()=>{ persistTemp(); alert("Saved to your browser."); };
$("load").onclick = ()=>{ loadTemp(); renderHoldings(); updateHoldingsPricesAndSignals(); };
$("reset").onclick = ()=>{ localStorage.removeItem("caleb_crypto_state"); HOLD=[]; renderHoldings(); computeSuggestions(); };

$("refresh").onclick = async ()=>{ CUR=$("vsCurrency").value; RISK=$("risk").value; await loadTop(); if($("assetSelect").value){ await loadHistory($("assetSelect").value, $("rangeSelect").value);} await updateHoldingsPricesAndSignals(); persistTemp();};
$("loadChart").onclick = async ()=>{ await loadHistory($("assetSelect").value, $("rangeSelect").value); };
$("risk").onchange = ()=>{ RISK=$("risk").value; loadTop(); updateHoldingsPricesAndSignals(); };
$("vsCurrency").onchange = ()=>{ CUR=$("vsCurrency").value; loadTop(); updateHoldingsPricesAndSignals(); };

$("loadNews").onclick = async ()=>{
  const items = await loadRSS($("newsSource").value);
  const scored = scoreNews(items);
  NEWS_SCORE = scored.score/2;
  $("newsFill").style.width = (50 + (NEWS_SCORE+NEWS_OVERRIDE)*5)+"%";
  $("newsScore").textContent = (NEWS_SCORE+NEWS_OVERRIDE).toFixed(1);
  const ul=$("newsList"); ul.innerHTML="";
  scored.items.slice(0,30).forEach(it=>{
    const li=document.createElement("li");
    const s = it.s>0?'chgUp': it.s<0?'chgDown':'';
    li.innerHTML = `<div class="${s}">${it.title}</div><div class="small">${it.pubDate?new Date(it.pubDate).toLocaleString():''} — <a href="${it.link}" target="_blank" rel="noopener">link</a></div>`;
    ul.appendChild(li);
  });
  await loadTop(); await updateHoldingsPricesAndSignals();
};
$("newsOverride").oninput = (e)=>{ NEWS_OVERRIDE=parseFloat(e.target.value)||0; $("newsOverrideVal").textContent = NEWS_OVERRIDE.toFixed(1); $("newsFill").style.width = (50 + (NEWS_SCORE+NEWS_OVERRIDE)*5)+"%"; loadTop(); updateHoldingsPricesAndSignals(); };

$("applyScenario").onclick = ()=>{ computeSuggestions(); renderHoldings(); };

$("addRow").onclick = async ()=>{
  await ensureCoinIndex();
  const q = $("search").value.trim();
  if(!q){ alert("Enter a coin to search (e.g., bitcoin)"); return; }
  const coin = findCoin(q);
  if(!coin){ alert("Not found"); return; }
  // fetch market data for name/symbol
  try{
    const res = await fetch(`${API}/coins/${coin.id}?localization=false&tickers=false&market_data=true&community_data=false&developer_data=false&sparkline=false`);
    const d = await res.json();
    HOLD.push({id: coin.id, symbol: d.symbol, name: d.name, amount: 0, cost: 0, target: 0, scenPct: 0, price: d.market_data?.current_price?.[CUR]||null, signalScore: 0});
    $("search").value="";
    persistTemp();
    renderHoldings();
    await updateHoldingsPricesAndSignals();
  }catch(e){ alert("Failed to add coin."); }
};

// INIT
(async function start(){
  loadTemp();
  await loadTop();
  if(TOP[0]){
    $("assetSelect").value = TOP[0].id;
    await loadHistory(TOP[0].id, 30);
  }
  renderHoldings();
  await updateHoldingsPricesAndSignals();
  $("loadNews").click();
})();
</script>
</body>
</html>
